### Packages
require(Rcpp)
require(RcppArmadillo)
require(RcppNumerical)
library(stats)
### Compile c++ code, read in fns from complied code
sourceCpp("../src/ARMS_slice_LOD_test.cpp", verbose = TRUE)
### Packages
require(Rcpp)
require(RcppArmadillo)
require(RcppNumerical)
library(stats)
### Compile c++ code, read in fns from complied code
sourceCpp("../src/ARMS_slice_LOD_test.cpp", verbose = TRUE)
sourceCpp("../src/ARMS_slice_LOD_test.cpp", verbose = TRUE)
sourceCpp("../src/ARMS_slice_LOD_test.cpp", verbose = TRUE)
sourceCpp("../src/ARMS_slice_LOD_test.cpp", verbose = TRUE)
### Packages
require(Rcpp)
require(RcppArmadillo)
require(RcppNumerical)
library(stats)
### Compile c++ code, read in fns from complied code
sourceCpp("../src/ARMS_slice_LOD_test.cpp", verbose = TRUE)
dataset <- load("../Data/lod_data_ex.RData")
dataset <- lod_data_ex
names(lod_data_ex)
formula <- c(Y~X1+X2+X3)
var_LOD <- c("X2", "X3")
finalEstimates <- list()
######################################################################
# Create required datasets                                           #
######################################################################
dataset_Y <- model.frame(frmla,data=dataset)[1]
dataset_X <- data.frame(model.matrix(frmla, dataset))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(d)
for(i in 1:length(var_LOD)){
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[i],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[i],
subData[[var_LOD[i]]], subd[i])
}
# Create data for analysis
## Obs (Data), complete case (ccData), sub (subData), and sub sqrt2 (sub2Data) datasets
ccData <- Data[complete.cases(Data),]
######################################################################
# Enter convergence criterion, LOD, etc.                             #
######################################################################
n <- dim(Data)[1]
nObservations <- n
frmla <- formula
dataset_Y <- model.frame(frmla,data=dataset)[1]
dataset_X <- data.frame(model.matrix(frmla, dataset))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
dataset
frmla
unlist(frmla)
finalEstimates <- list()
######################################################################
# Create required datasets                                           #
######################################################################
dataset_Y <- model.frame(frmla,data=dataset)[1]
frmla <- Y~X1+X2+X3
finalEstimates <- list()
######################################################################
# Create required datasets                                           #
######################################################################
dataset_Y <- model.frame(frmla,data=dataset)[1]
dataset_X <- data.frame(model.matrix(frmla, dataset))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(d)
for(i in 1:length(var_LOD)){
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[i],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[i],
subData[[var_LOD[i]]], subd[i])
}
# Create data for analysis
## Obs (Data), complete case (ccData), sub (subData), and sub sqrt2 (sub2Data) datasets
ccData <- Data[complete.cases(Data),]
d <- c(0,0)
dataset_X <- data.frame(model.matrix(frmla, dataset))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(d)
for(i in 1:length(var_LOD)){
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[i],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[i],
subData[[var_LOD[i]]], subd[i])
}
# Create data for analysis
## Obs (Data), complete case (ccData), sub (subData), and sub sqrt2 (sub2Data) datasets
ccData <- Data[complete.cases(Data),]
n <- dim(Data)[1]
nObservations <- n
#######################################################################
# Perform Complete-Case, Substitution Analysis                        #
#######################################################################
ccModel <- glm( frmla,
family = gaussian(), data = ccData )
ccSub_LOD <- glm( frmla,
family = gaussian(), data = subData )
# Using LOD/sqrt(2) for sub
ccSub_LODsqrt2 <- glm( frmla,
family = gaussian(), data = sub2Data )
BetaEstimatesCC <- as.numeric( summary( ccModel )$coefficients[,1])
names(BetaEstimatesCC) <- rownames(summary( ccModel )$coefficients)
BetaEstimatesSubsqrt2 <- as.numeric( summary( ccSub_LODsqrt2 )$coefficients[,1])
names(BetaEstimatesSubsqrt2) <- rownames(summary( ccSub_LODsqrt2 )$coefficients)
# Extract mean vector estimate and covariance matrix estimate of covariates
cat_var <- names(ccModel$contrasts)
length_unique <- function(x){length(unique(x))}
unique_values <- apply(dataset_X, MARGIN=2,FUN=length_unique)
binary_vars <- names(unique_values[unique_values<3])
remove_vars <- c(var_LOD, cat_var, binary_vars)
var_noLOD <- names(dataset_X[,!(names(dataset_X)%in%remove_vars),
drop=FALSE])
xMeanCC <- apply( ccData[,c(var_noLOD, var_LOD)], 2, mean ) #-1 to eliminate outcome Y
xCovCC <- cov( ccData[,c(var_noLOD, var_LOD)] )
#######################################################################
# Perform ARMS MLE Sampling using C++ compiled code                                          #
#######################################################################
# Create matrix to hold limits of detection
LOD_mat <- cbind(rep(-100, dim(Data[,-1])[2]), rep(NA, dim(Data[,-1])[2]))
LOD_mat[which(names(Data[,-1])%in%var_LOD),2] <- d
LOD_mat
Data
frmla
frmla <- Y ~ X3 + X2 + X1
finalEstimates <- list()
######################################################################
# Create required datasets                                           #
######################################################################
dataset_Y <- model.frame(frmla,data=dataset)[1]
dataset_X <- data.frame(model.matrix(frmla, dataset))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
names(dataset_X)
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(d)
for(i in 1:length(var_LOD)){
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[i],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[i],
subData[[var_LOD[i]]], subd[i])
}
# Create data for analysis
## Obs (Data), complete case (ccData), sub (subData), and sub sqrt2 (sub2Data) datasets
ccData <- Data[complete.cases(Data),]
######################################################################
# Enter convergence criterion, LOD, etc.                             #
######################################################################
n <- dim(Data)[1]
nObservations <- n
#######################################################################
# Perform Complete-Case, Substitution Analysis                        #
#######################################################################
ccModel <- glm( frmla,
family = gaussian(), data = ccData )
######################################################################
# Perform all Substitution Analyses                                  #
######################################################################
# Using LOD for sub
ccSub_LOD <- glm( frmla,
family = gaussian(), data = subData )
# Using LOD/sqrt(2) for sub
ccSub_LODsqrt2 <- glm( frmla,
family = gaussian(), data = sub2Data )
######################################################################
# Obtain parameter estimates to be used as initial estimates in ARMS #
######################################################################
# Extract Beta and residual variance
BetaEstimatesCC <- as.numeric( summary( ccModel )$coefficients[,1])
names(BetaEstimatesCC) <- rownames(summary( ccModel )$coefficients)
BetaEstimatesSubsqrt2 <- as.numeric( summary( ccSub_LODsqrt2 )$coefficients[,1])
names(BetaEstimatesSubsqrt2) <- rownames(summary( ccSub_LODsqrt2 )$coefficients)
# Extract mean vector estimate and covariance matrix estimate of covariates
cat_var <- names(ccModel$contrasts)
length_unique <- function(x){length(unique(x))}
unique_values <- apply(dataset_X, MARGIN=2,FUN=length_unique)
binary_vars <- names(unique_values[unique_values<3])
remove_vars <- c(var_LOD, cat_var, binary_vars)
var_noLOD <- names(dataset_X[,!(names(dataset_X)%in%remove_vars),
drop=FALSE])
xMeanCC <- apply( ccData[,c(var_noLOD, var_LOD)], 2, mean ) #-1 to eliminate outcome Y
xCovCC <- cov( ccData[,c(var_noLOD, var_LOD)] )
#######################################################################
# Perform ARMS MLE Sampling using C++ compiled code                                          #
#######################################################################
# Create matrix to hold limits of detection
LOD_mat <- cbind(rep(-100, dim(Data[,-1])[2]), rep(NA, dim(Data[,-1])[2]))
LOD_mat[which(names(Data[,-1])%in%var_LOD),2] <- d
LOD_mat
frmla
est_obj <- LOD_fit_multiple(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=250, threshold = 0.001, max_iterations = 100,
LOD_u_l = LOD_mat,
sampler = 0)
library(Rcpp)
library(RcppArmadillo)
sourceCpp(file="../src/ARMS_slice_LOD_test.cpp")
est_obj <- LOD_fit_multiple(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=250, threshold = 0.001, max_iterations = 100,
LOD_u_l = LOD_mat,
sampler = 0)
est_obj
frmla <- Y~X1+X2+X3
finalEstimates <- list()
######################################################################
# Create required datasets                                           #
######################################################################
dataset_Y <- model.frame(frmla,data=dataset)[1]
dataset_X <- data.frame(model.matrix(frmla, dataset))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(d)
for(i in 1:length(var_LOD)){
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[i],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[i],
subData[[var_LOD[i]]], subd[i])
}
# Create data for analysis
## Obs (Data), complete case (ccData), sub (subData), and sub sqrt2 (sub2Data) datasets
ccData <- Data[complete.cases(Data),]
######################################################################
# Enter convergence criterion, LOD, etc.                             #
######################################################################
n <- dim(Data)[1]
nObservations <- n
#######################################################################
# Perform Complete-Case, Substitution Analysis                        #
#######################################################################
ccModel <- glm( frmla,
family = gaussian(), data = ccData )
######################################################################
# Perform all Substitution Analyses                                  #
######################################################################
# Using LOD for sub
ccSub_LOD <- glm( frmla,
family = gaussian(), data = subData )
# Using LOD/sqrt(2) for sub
ccSub_LODsqrt2 <- glm( frmla,
family = gaussian(), data = sub2Data )
######################################################################
# Obtain parameter estimates to be used as initial estimates in ARMS #
######################################################################
# Extract Beta and residual variance
BetaEstimatesCC <- as.numeric( summary( ccModel )$coefficients[,1])
names(BetaEstimatesCC) <- rownames(summary( ccModel )$coefficients)
BetaEstimatesSubsqrt2 <- as.numeric( summary( ccSub_LODsqrt2 )$coefficients[,1])
names(BetaEstimatesSubsqrt2) <- rownames(summary( ccSub_LODsqrt2 )$coefficients)
# Extract mean vector estimate and covariance matrix estimate of covariates
cat_var <- names(ccModel$contrasts)
length_unique <- function(x){length(unique(x))}
unique_values <- apply(dataset_X, MARGIN=2,FUN=length_unique)
binary_vars <- names(unique_values[unique_values<3])
remove_vars <- c(var_LOD, cat_var, binary_vars)
var_noLOD <- names(dataset_X[,!(names(dataset_X)%in%remove_vars),
drop=FALSE])
xMeanCC <- apply( ccData[,c(var_noLOD, var_LOD)], 2, mean ) #-1 to eliminate outcome Y
xCovCC <- cov( ccData[,c(var_noLOD, var_LOD)] )
#######################################################################
# Perform ARMS MLE Sampling using C++ compiled code                                          #
#######################################################################
# Create matrix to hold limits of detection
LOD_mat <- cbind(rep(-100, dim(Data[,-1])[2]), rep(NA, dim(Data[,-1])[2]))
LOD_mat[which(names(Data[,-1])%in%var_LOD),2] <- d
# Estimation
est_obj <- LOD_fit_multiple(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=250, threshold = 0.001, max_iterations = 100,
LOD_u_l = LOD_mat,
sampler = 0)
est_obj
