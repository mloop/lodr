sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 10,
LOD_u_l = LOD_mat,
sampler = 0)
hist(est_obj$x_data_return_last_int[,2])
hist(est_obj$x_data_return_last_int[,4])
nSamples=5
convergenceCriterion=0.001
data=lodr::lod_data_ex
frmla=Y~X2+X1+X3
lod=c(0, 0)
var_LOD = c("X2","X3")
dataset_Y <- model.frame(frmla,data=data)[1]
dataset_X <- data.frame(model.matrix(frmla, data))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(lod)
for(i in 1:length(var_LOD)){
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>lod[i],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>lod[i],
subData[[var_LOD[i]]], subd[i])
}
# Create data for analysis
## Obs (Data), complete case (ccData), sub (subData), and sub sqrt2 (sub2Data) datasets
ccData <- Data[complete.cases(Data),]
######################################################################
# Enter convergence criterion, LOD, etc.                             #
######################################################################
n <- dim(Data)[1]
nObservations <- n
#######################################################################
# Perform Complete-Case, Substitution Analysis                        #
#######################################################################
ccModel <- glm( frmla,
family = gaussian(), data = ccData )
######################################################################
# Perform all Substitution Analyses                                  #
######################################################################
# Using LOD for sub
ccSub_LOD <- glm( frmla,
family = gaussian(), data = subData )
# Using LOD/sqrt(2) for sub
ccSub_LODsqrt2 <- glm( frmla,
family = gaussian(), data = sub2Data )
######################################################################
# Obtain parameter estimates to be used as initial estimates in ARMS #
######################################################################
# Extract Beta and residual variance
BetaEstimatesCC <- as.numeric( summary( ccModel )$coefficients[,1])
names(BetaEstimatesCC) <- rownames(summary( ccModel )$coefficients)
BetaEstimatesSubsqrt2 <- as.numeric( summary( ccSub_LODsqrt2 )$coefficients[,1])
names(BetaEstimatesSubsqrt2) <- rownames(summary( ccSub_LODsqrt2 )$coefficients)
# Extract mean vector estimate and covariance matrix estimate of covariates
cat_var <- names(ccModel$contrasts)
length_unique <- function(x){length(unique(x))}
unique_values <- apply(dataset_X, MARGIN=2,FUN=length_unique)
binary_vars <- names(unique_values[unique_values<3])
remove_vars <- c(var_LOD, cat_var, binary_vars)
var_noLOD <- names(dataset_X[,!(names(dataset_X)%in%remove_vars),
drop=FALSE])
var_keep <- names(ccData)[names(ccData) %in% c(var_noLOD, var_LOD)]
xMeanCC <- apply( ccData[,var_keep], 2, mean ) #-1 to eliminate outcome Y
xCovCC <- cov( ccData[,var_keep] )
#######################################################################
# Perform ARMS MLE Sampling using C++ compiled code                                          #
#######################################################################
# Create matrix to hold limits of detection
LOD_mat <- cbind(rep(-100, dim(Data[,-1])[2]), rep(NA, dim(Data[,-1])[2]))
LOD_mat[which(names(Data[,-1])%in%var_LOD),2] <- lod
# Estimation
est_obj <- debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 10,
LOD_u_l = LOD_mat,
sampler = 0)
hist(est_obj$x_data_return_last_int[,2])
est_obj <- debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 2,
LOD_u_l = LOD_mat,
sampler = 0)
hist(est_obj$x_data_return_last_int[,2])
est_obj <- debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 3,
LOD_u_l = LOD_mat,
sampler = 0)
hist(est_obj$x_data_return_last_int[,2])
est_obj <- debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 4,
LOD_u_l = LOD_mat,
sampler = 0)
hist(est_obj$x_data_return_last_int[,2])
est_obj <- debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
hist(est_obj$x_data_return_last_int[,2])
sourceCpp("src/ARMS_slice_LOD.cpp")
nSamples=5
convergenceCriterion=0.001
data=lodr::lod_data_ex
frmla=Y~X2+X1+X3
lod=c(0, 0)
var_LOD = c("X2","X3")
est_obj <- debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
hist(est_obj$x_data_return_last_int[,2])
est_obj$beta_estimates
est_obj$x_data_return_last_int
est_obj <- debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 100,
LOD_u_l = LOD_mat,
sampler = 0)
est_obj$beta_estimates
sourceCpp("src/ARMS_slice_LOD.cpp")
nSamples=5
convergenceCriterion=0.001
data=lodr::lod_data_ex
frmla=Y~X2+X1+X3
lod=c(0, 0)
var_LOD = c("X2","X3")
est_obj <- debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 100,
LOD_u_l = LOD_mat,
sampler = 0)
est_obj$beta_estimates
sourceCpp("src/ARMS_slice_LOD.cpp")
nSamples=5
convergenceCriterion=0.001
data=lodr::lod_data_ex
frmla=Y~X2+X1+X3
lod=c(0, 0)
var_LOD = c("X2","X3")
est_obj <- debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
sourceCpp("src/ARMS_slice_LOD.cpp")
est_obj <- debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
sourceCpp("src/ARMS_slice_LOD.cpp")
sourceCpp("src/ARMS_slice_LOD.cpp")
est_obj <- debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
sourceCpp("src/ARMS_slice_LOD.cpp")
est_obj <- debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
est_obj <- debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 3,
LOD_u_l = LOD_mat,
sampler = 0)
View(est_obj$x_data_return_last_int)
est_obj <- debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 10,
LOD_u_l = LOD_mat,
sampler = 0)
View(est_obj$x_data_return_last_int)
sourceCpp("src/ARMS_slice_LOD.cpp")
debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 10,
LOD_u_l = LOD_mat,
sampler = 0)
sourceCpp("src/ARMS_slice_LOD.cpp")
debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 10,
LOD_u_l = LOD_mat,
sampler = 0)
sourceCpp("src/ARMS_slice_LOD.cpp")
sourceCpp("src/ARMS_slice_LOD.cpp")
debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 10,
LOD_u_l = LOD_mat,
sampler = 0)
sourceCpp("src/ARMS_slice_LOD.cpp")
debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 10,
LOD_u_l = LOD_mat,
sampler = 0)
sourceCpp("src/ARMS_slice_LOD.cpp")
sourceCpp("src/ARMS_slice_LOD.cpp")
debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 10,
LOD_u_l = LOD_mat,
sampler = 0)
sourceCpp("src/ARMS_slice_LOD.cpp")
debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 10,
LOD_u_l = LOD_mat,
sampler = 0)
nSamples=5
convergenceCriterion=0.001
data=lodr::lod_data_ex
frmla=Y~X1+X2+X3
lod=c(0, 0)
var_LOD = c("X2","X3")
dataset_Y <- model.frame(frmla,data=data)[1]
dataset_X <- data.frame(model.matrix(frmla, data))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(lod)
for(i in 1:length(var_LOD)){
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>lod[i],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>lod[i],
subData[[var_LOD[i]]], subd[i])
}
# Create data for analysis
## Obs (Data), complete case (ccData), sub (subData), and sub sqrt2 (sub2Data) datasets
ccData <- Data[complete.cases(Data),]
######################################################################
# Enter convergence criterion, LOD, etc.                             #
######################################################################
n <- dim(Data)[1]
nObservations <- n
#######################################################################
# Perform Complete-Case, Substitution Analysis                        #
#######################################################################
ccModel <- glm( frmla,
family = gaussian(), data = ccData )
######################################################################
# Perform all Substitution Analyses                                  #
######################################################################
# Using LOD for sub
ccSub_LOD <- glm( frmla,
family = gaussian(), data = subData )
# Using LOD/sqrt(2) for sub
ccSub_LODsqrt2 <- glm( frmla,
family = gaussian(), data = sub2Data )
######################################################################
# Obtain parameter estimates to be used as initial estimates in ARMS #
######################################################################
# Extract Beta and residual variance
BetaEstimatesCC <- as.numeric( summary( ccModel )$coefficients[,1])
names(BetaEstimatesCC) <- rownames(summary( ccModel )$coefficients)
BetaEstimatesSubsqrt2 <- as.numeric( summary( ccSub_LODsqrt2 )$coefficients[,1])
names(BetaEstimatesSubsqrt2) <- rownames(summary( ccSub_LODsqrt2 )$coefficients)
# Extract mean vector estimate and covariance matrix estimate of covariates
cat_var <- names(ccModel$contrasts)
length_unique <- function(x){length(unique(x))}
unique_values <- apply(dataset_X, MARGIN=2,FUN=length_unique)
binary_vars <- names(unique_values[unique_values<3])
remove_vars <- c(var_LOD, cat_var, binary_vars)
var_noLOD <- names(dataset_X[,!(names(dataset_X)%in%remove_vars),
drop=FALSE])
var_keep <- names(ccData)[names(ccData) %in% c(var_noLOD, var_LOD)]
xMeanCC <- apply( ccData[,var_keep], 2, mean ) #-1 to eliminate outcome Y
xCovCC <- cov( ccData[,var_keep] )
#######################################################################
# Perform ARMS MLE Sampling using C++ compiled code                                          #
#######################################################################
# Create matrix to hold limits of detection
LOD_mat <- cbind(rep(-100, dim(Data[,-1])[2]), rep(NA, dim(Data[,-1])[2]))
LOD_mat[which(names(Data[,-1])%in%var_LOD),2] <- lod
debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 10,
LOD_u_l = LOD_mat,
sampler = 0)
sourceCpp("src/ARMS_slice_LOD.cpp")
sourceCpp("src/ARMS_slice_LOD.cpp")
Data
y_data_extract <- Data[100,1]
x_data_extract <- Data[100,-1]
x_data_extract
x_data_extract[is.na(x_data_extract)]
x_data_extract[is.na(x_data_extract)] <- 0
x_data_extract
nSamples=5
convergenceCriterion=0.001
data=lodr::lod_data_ex
frmla=Y~X2+X1+X3
lod=c(0, 0)
var_LOD = c("X2","X3")
dataset_Y <- model.frame(frmla,data=data)[1]
dataset_X <- data.frame(model.matrix(frmla, data))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(lod)
for(i in 1:length(var_LOD)){
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>lod[i],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>lod[i],
subData[[var_LOD[i]]], subd[i])
}
# Create data for analysis
## Obs (Data), complete case (ccData), sub (subData), and sub sqrt2 (sub2Data) datasets
ccData <- Data[complete.cases(Data),]
######################################################################
# Enter convergence criterion, LOD, etc.                             #
######################################################################
n <- dim(Data)[1]
nObservations <- n
#######################################################################
# Perform Complete-Case, Substitution Analysis                        #
#######################################################################
ccModel <- glm( frmla,
family = gaussian(), data = ccData )
######################################################################
# Perform all Substitution Analyses                                  #
######################################################################
# Using LOD for sub
ccSub_LOD <- glm( frmla,
family = gaussian(), data = subData )
# Using LOD/sqrt(2) for sub
ccSub_LODsqrt2 <- glm( frmla,
family = gaussian(), data = sub2Data )
######################################################################
# Obtain parameter estimates to be used as initial estimates in ARMS #
######################################################################
# Extract Beta and residual variance
BetaEstimatesCC <- as.numeric( summary( ccModel )$coefficients[,1])
names(BetaEstimatesCC) <- rownames(summary( ccModel )$coefficients)
BetaEstimatesSubsqrt2 <- as.numeric( summary( ccSub_LODsqrt2 )$coefficients[,1])
names(BetaEstimatesSubsqrt2) <- rownames(summary( ccSub_LODsqrt2 )$coefficients)
# Extract mean vector estimate and covariance matrix estimate of covariates
cat_var <- names(ccModel$contrasts)
length_unique <- function(x){length(unique(x))}
unique_values <- apply(dataset_X, MARGIN=2,FUN=length_unique)
binary_vars <- names(unique_values[unique_values<3])
remove_vars <- c(var_LOD, cat_var, binary_vars)
var_noLOD <- names(dataset_X[,!(names(dataset_X)%in%remove_vars),
drop=FALSE])
var_keep <- names(ccData)[names(ccData) %in% c(var_noLOD, var_LOD)]
xMeanCC <- apply( ccData[,var_keep], 2, mean ) #-1 to eliminate outcome Y
xCovCC <- cov( ccData[,var_keep] )
#######################################################################
# Perform ARMS MLE Sampling using C++ compiled code                                          #
#######################################################################
# Create matrix to hold limits of detection
LOD_mat <- cbind(rep(-100, dim(Data[,-1])[2]), rep(NA, dim(Data[,-1])[2]))
LOD_mat[which(names(Data[,-1])%in%var_LOD),2] <- lod
# Estimation
est_obj <- debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 10,
LOD_u_l = LOD_mat,
sampler = 0)
y_data_extract <- Data[100,1]
x_data_extract <- Data[100,-1]
x_data_extract[is.na(x_data_extract)] <- 0
x_data_extract
xCovCC
slice_fcs_debug(y=y_data_extract,
obs_preds=x_data_extract,
missing_pred = 1,
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
init_x0 = x_data_extract[1]
)
slice_fcs_debug(y=y_data_extract,
obs_preds=x_data_extract,
missing_pred = 1L,
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
init_x0 = x_data_extract[1]
)
