compileAttributes()
using namespace Rcpp;
require(Rcpp)
compileAttributes()
sourceCpp("src/ARMS_slice_LOD_test.cpp", verbose = TRUE)
sourceCpp("src/ARMS_slice_LOD_test.cpp", verbose = TRUE)
### Packages
require(Rcpp)
require(RcppArmadillo)
require(RcppNumerical)
library(stats)
### Compile c++ code, read in fns from complied code
sourceCpp("src/ARMS_slice_LOD_test.cpp", verbose = TRUE)
Rcpp.package.skeleton()
Sys.setenv("PKG_CXXFLAGS"="-std=c++11")
Rcpp::compileAttributes()
Rcpp::compileAttributes()
Rcpp::compileAttributes()
?compileAttributes
Rcpp::compileAttributes(verbose = TRUE)
Rcpp::compileAttributes(verbose = TRUE)
require(Rcpp)
require(RcppArmadillo)
require(RcppNumerical)
library(stats)
compileAttributes()
compileAttributes(verbose = TRUE)
Sys.setenv("PKG_CXXFLAGS"="-std=c++11")
compileAttributes(verbose = TRUE)
sourceCpp("src/ARMS_slice_LOD_test.cpp", verbose = TRUE)
RcppArmadillo.package.skeleton()
RcppArmadillo.package.skeleton()
### Packages
require(Rcpp)
require(RcppArmadillo)
require(RcppNumerical)
RcppArmadillo.package.skeleton()
compileAttributes()
library(lodr)
library(lodr)
library(lodr)
library(lodr)
library(lodr)
lodr::dataset
## Load R packages; make sure to inclde Rcpp packages
require(Rcpp)
require(RcppArmadillo)
require(RcppNumerical)
library(MASS)
library(HI)
library(tidyverse)
## Example 3: 50% LOD
n <- 100
x_data <- cbind(rep(1, n),mvrnorm(n,c(0,0,0),matrix(c(1,0,0,0,1,0,0,0,1),3)))
y_data <- x_data%*%t(t(c(1,1,1,1)))+rnorm(n,0,1)
LOD_rate <- 0.5; LOD_mat = rbind(c(NA, NA),
c(NA, NA),
c(-100, qnorm(LOD_rate)),
c(-100, qnorm(LOD_rate)))
x_data_obs <- x_data
x_data_obs[x_data_obs[,4] < qnorm(LOD_rate),4] = NA
data_obs <- data.frame(y_data, x_data_obs)
fit <- lm(y_data~X2+X3+X4, data=data_obs)
lod_ex_dataset <- list("Data"=data_obs, "LOD_matrix"=LOD_mat)
save(lod_ex_data, file="Data/lod_ex_data.RData")
lod_ex_data <- list("Data"=data_obs, "LOD_matrix"=LOD_mat)
save(lod_ex_data, file="Data/lod_ex_data.RData")
compileAttributes()
library(lodr)
names(lod_ex_data$Data)
lod_ex_data$Data
LOD_regression(dataset = lod_ex_data$Data, d=lod_ex_data$LOD_matrix, frmla = y_data~X2+X3+X4, var_LOD = "X4")
library(lodr)
dataset <- lod_ex_data$Data
names(dataset)
frmla <- Y~X1+X2+X3
d <- lod_ex_data$LOD_matrix
var_LOD <- c("X1", "X2")
var_LOD
dataset_Y <- model.frame(frmla,data=dataset)[1]
dataset_Y
dataset_X <- data.frame(model.matrix(frmla, dataset))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(d)
for(i in 1:length(var_LOD)){
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[i],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[i],
subData[[var_LOD[i]]], subd[i])
}
# Create data for analysis
## Obs (Data), complete case (ccData), sub (subData), and sub sqrt2 (sub2Data) datasets
ccData <- Data[complete.cases(Data),]
Data
subData
library(lodr)
dataset <- lod_ex_data$Data
frmla <- Y~X1+X2+X3
names(dataset)
var_LOD <- c("X2", "X3")
d <- lod_ex_data$LOD_matrix
dataset_Y <- model.frame(frmla,data=dataset)[1]
dataset_X <- data.frame(model.matrix(frmla, dataset))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
subData
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(d)
for(i in 1:length(var_LOD)){
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[i],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[i],
subData[[var_LOD[i]]], subd[i])
}
Data
sub2Data
var_LOD
d
i
d[i]
var_LOD
Data
which(names(Data)==var_LOD[i])
names(dataset_X)
which(names(dataset_X)==var_LOD[i])
Data[,-1]
dataset_Y <- model.frame(frmla,data=dataset)[1]
dataset_X <- data.frame(model.matrix(frmla, dataset))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(d)
for(i in 1:length(var_LOD)){
LOD_index <- which(names(Data[,-1])==var_LOD[i])
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[LOD_index,2],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[LOD_index,2],
subData[[var_LOD[i]]], subd[i])
}
subData
Data
sub2Data
subd
dataset_Y <- model.frame(frmla,data=dataset)[1]
dataset_X <- data.frame(model.matrix(frmla, dataset))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(d)
for(i in 1:length(var_LOD)){
LOD_index <- which(names(Data[,-1])==var_LOD[i])
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[LOD_index,2],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[LOD_index,2],
subData[[var_LOD[i]]], subd[LOD_index,2])
}
# Create data for analysis
## Obs (Data), complete case (ccData), sub (subData), and sub sqrt2 (sub2Data) datasets
ccData <- Data[complete.cases(Data),]
sub2Data
ccData
n <- dim(Data)[1]
nObservations <- n
#######################################################################
# Perform Complete-Case, Substitution Analysis                        #
#######################################################################
ccModel <- glm( frmla,
family = gaussian(), data = ccData )
######################################################################
# Perform all Substitution Analyses                                  #
######################################################################
# Using LOD for sub
ccSub_LOD <- glm( frmla,
family = gaussian(), data = subData )
# Using LOD/sqrt(2) for sub
ccSub_LODsqrt2 <- glm( frmla,
family = gaussian(), data = sub2Data )
######################################################################
# Obtain parameter estimates to be used as initial estimates in ARMS #
######################################################################
# Extract Beta and residual variance
BetaEstimatesCC <- as.numeric( summary( ccModel )$coefficients[,1])
names(BetaEstimatesCC) <- rownames(summary( ccModel )$coefficients)
BetaEstimatesSubsqrt2 <- as.numeric( summary( ccSub_LODsqrt2 )$coefficients[,1])
names(BetaEstimatesSubsqrt2) <- rownames(summary( ccSub_LODsqrt2 )$coefficients)
# Extract mean vector estimate and covariance matrix estimate of covariates
cat_var <- names(ccModel$contrasts)
length_unique <- function(x){length(unique(x))}
unique_values <- apply(dataset_X, MARGIN=2,FUN=length_unique)
binary_vars <- names(unique_values[unique_values<3])
remove_vars <- c(var_LOD, cat_var, binary_vars)
var_noLOD <- names(dataset_X[,!(names(dataset_X)%in%remove_vars),
drop=FALSE])
xMeanCC <- apply( ccData[,c(var_noLOD, var_LOD)], 2, mean ) #-1 to eliminate outcome Y
xCovCC <- cov( ccData[,c(var_noLOD, var_LOD)] )
#######################################################################
# Perform ARMS MLE Sampling using C++ compiled code                                          #
#######################################################################
# Create matrix to hold limits of detection
LOD_mat <- cbind(rep(-100, dim(Data[,-1])[2]), rep(NA, dim(Data[,-1])[2]))
LOD_mat[which(names(Data[,-1])%in%var_LOD),2] <- d
LOD_mat
d <- c(0,0)
d
var_LOD
dataset_Y <- model.frame(frmla,data=dataset)[1]
dataset_X <- data.frame(model.matrix(frmla, dataset))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(d)
for(i in 1:length(var_LOD)){
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[i],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>d[i],
subData[[var_LOD[i]]], subd[i])
}
Data
sub2Data
ccData <- Data[complete.cases(Data),]
######################################################################
# Enter convergence criterion, LOD, etc.                             #
######################################################################
n <- dim(Data)[1]
nObservations <- n
#######################################################################
# Perform Complete-Case, Substitution Analysis                        #
#######################################################################
ccModel <- glm( frmla,
family = gaussian(), data = ccData )
######################################################################
# Perform all Substitution Analyses                                  #
######################################################################
# Using LOD for sub
ccSub_LOD <- glm( frmla,
family = gaussian(), data = subData )
# Using LOD/sqrt(2) for sub
ccSub_LODsqrt2 <- glm( frmla,
family = gaussian(), data = sub2Data )
######################################################################
# Obtain parameter estimates to be used as initial estimates in ARMS #
######################################################################
# Extract Beta and residual variance
BetaEstimatesCC <- as.numeric( summary( ccModel )$coefficients[,1])
names(BetaEstimatesCC) <- rownames(summary( ccModel )$coefficients)
BetaEstimatesSubsqrt2 <- as.numeric( summary( ccSub_LODsqrt2 )$coefficients[,1])
names(BetaEstimatesSubsqrt2) <- rownames(summary( ccSub_LODsqrt2 )$coefficients)
# Extract mean vector estimate and covariance matrix estimate of covariates
cat_var <- names(ccModel$contrasts)
length_unique <- function(x){length(unique(x))}
unique_values <- apply(dataset_X, MARGIN=2,FUN=length_unique)
binary_vars <- names(unique_values[unique_values<3])
remove_vars <- c(var_LOD, cat_var, binary_vars)
var_noLOD <- names(dataset_X[,!(names(dataset_X)%in%remove_vars),
drop=FALSE])
xMeanCC <- apply( ccData[,c(var_noLOD, var_LOD)], 2, mean ) #-1 to eliminate outcome Y
xCovCC <- cov( ccData[,c(var_noLOD, var_LOD)] )
#######################################################################
# Perform ARMS MLE Sampling using C++ compiled code                                          #
#######################################################################
# Create matrix to hold limits of detection
LOD_mat <- cbind(rep(-100, dim(Data[,-1])[2]), rep(NA, dim(Data[,-1])[2]))
LOD_mat[which(names(Data[,-1])%in%var_LOD),2] <- d
LOD_mat
est_obj <- LOD_fit_multiple(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=250, threshold = 0.001, max_iterations = 100,
LOD_u_l = LOD_mat,
sampler = 0)
finalEstimates <- list()
finalEstimates$coefficients <- LOD_ests
finalEstimates$fitted.values <- as.matrix(Data[,-1])%*%LOD_ests
finalEstimates$rank <- dim(Data[,-1])[2]
finalEstimates$residuals <- Data[,1]-finalEstimates$fitted.values
finalEstimates$df.residual <- n-dim(Data[,-1])[2]
if(!is.null(cat_var)){
finalEstimates$xlevels <- list()
for(i in 1:length(cat_var)){
finalEstimates$xlevels[[cat_var]] <- levels(subData[[cat_var]])
}
}
finalEstimates$model <- subset(Data, select=-c(Intercept))
finalEstimates$terms <- ccModel$terms
library(lodr)
LOD_regression(dataset=lod_data_ex$Data, frmla=Y~X1+X2+X3,d=lod_data_ex$LODs, var_LOD = c("X2", "X3"))
library(lodr)
LOD_regression(dataset=lod_data_ex$Data, frmla=Y~X1+X2+X3,d=lod_data_ex$LODs, var_LOD = c("X2", "X3"))
Rcpp::compileAttributes()
library(lodr)
