# Enter convergence criterion, LOD, etc.                             #
######################################################################
n <- dim(Data)[1]
nObservations <- n
#######################################################################
# Perform Complete-Case, Substitution Analysis                        #
#######################################################################
ccModel <- glm( frmla,
family = gaussian(), data = ccData )
######################################################################
# Perform all Substitution Analyses                                  #
######################################################################
# Using LOD for sub
ccSub_LOD <- glm( frmla,
family = gaussian(), data = subData )
# Using LOD/sqrt(2) for sub
ccSub_LODsqrt2 <- glm( frmla,
family = gaussian(), data = sub2Data )
######################################################################
# Obtain parameter estimates to be used as initial estimates in ARMS #
######################################################################
# Extract Beta and residual variance
BetaEstimatesCC <- as.numeric( summary( ccModel )$coefficients[,1])
names(BetaEstimatesCC) <- rownames(summary( ccModel )$coefficients)
BetaEstimatesSubsqrt2 <- as.numeric( summary( ccSub_LODsqrt2 )$coefficients[,1])
names(BetaEstimatesSubsqrt2) <- rownames(summary( ccSub_LODsqrt2 )$coefficients)
# Extract mean vector estimate and covariance matrix estimate of covariates
cat_var <- names(ccModel$contrasts)
length_unique <- function(x){length(unique(x))}
unique_values <- apply(dataset_X, MARGIN=2,FUN=length_unique)
binary_vars <- names(unique_values[unique_values<3])
remove_vars <- c(var_LOD, cat_var, binary_vars)
var_noLOD <- names(dataset_X[,!(names(dataset_X)%in%remove_vars),
drop=FALSE])
var_keep <- names(ccData)[names(ccData) %in% c(var_noLOD, var_LOD)]
xMeanCC <- apply( ccData[,var_keep], 2, mean ) #-1 to eliminate outcome Y
xCovCC <- cov( ccData[,var_keep] )
#######################################################################
# Perform ARMS MLE Sampling using C++ compiled code                                          #
#######################################################################
# Create matrix to hold limits of detection
LOD_mat <- cbind(rep(-100, dim(Data[,-1])[2]), rep(NA, dim(Data[,-1])[2]))
LOD_mat[which(names(Data[,-1])%in%var_LOD),2] <- lod
frmla
lod <- "X3"
d <- 0
dataset_Y <- model.frame(frmla,data=data)[1]
dataset_X <- data.frame(model.matrix(frmla, data))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(lod)
for(i in 1:length(var_LOD)){
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>lod[i],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>lod[i],
subData[[var_LOD[i]]], subd[i])
}
# Create data for analysis
## Obs (Data), complete case (ccData), sub (subData), and sub sqrt2 (sub2Data) datasets
ccData <- Data[complete.cases(Data),]
######################################################################
# Enter convergence criterion, LOD, etc.                             #
######################################################################
n <- dim(Data)[1]
nObservations <- n
#######################################################################
# Perform Complete-Case, Substitution Analysis                        #
#######################################################################
ccModel <- glm( frmla,
family = gaussian(), data = ccData )
######################################################################
# Perform all Substitution Analyses                                  #
######################################################################
# Using LOD for sub
ccSub_LOD <- glm( frmla,
family = gaussian(), data = subData )
# Using LOD/sqrt(2) for sub
ccSub_LODsqrt2 <- glm( frmla,
family = gaussian(), data = sub2Data )
######################################################################
# Obtain parameter estimates to be used as initial estimates in ARMS #
######################################################################
# Extract Beta and residual variance
BetaEstimatesCC <- as.numeric( summary( ccModel )$coefficients[,1])
names(BetaEstimatesCC) <- rownames(summary( ccModel )$coefficients)
BetaEstimatesSubsqrt2 <- as.numeric( summary( ccSub_LODsqrt2 )$coefficients[,1])
names(BetaEstimatesSubsqrt2) <- rownames(summary( ccSub_LODsqrt2 )$coefficients)
# Extract mean vector estimate and covariance matrix estimate of covariates
cat_var <- names(ccModel$contrasts)
length_unique <- function(x){length(unique(x))}
unique_values <- apply(dataset_X, MARGIN=2,FUN=length_unique)
binary_vars <- names(unique_values[unique_values<3])
remove_vars <- c(var_LOD, cat_var, binary_vars)
var_noLOD <- names(dataset_X[,!(names(dataset_X)%in%remove_vars),
drop=FALSE])
var_keep <- names(ccData)[names(ccData) %in% c(var_noLOD, var_LOD)]
xMeanCC <- apply( ccData[,var_keep], 2, mean ) #-1 to eliminate outcome Y
xCovCC <- cov( ccData[,var_keep] )
#######################################################################
# Perform ARMS MLE Sampling using C++ compiled code                                          #
#######################################################################
# Create matrix to hold limits of detection
LOD_mat <- cbind(rep(-100, dim(Data[,-1])[2]), rep(NA, dim(Data[,-1])[2]))
LOD_mat[which(names(Data[,-1])%in%var_LOD),2] <- lod
dataset_Y <- model.frame(frmla,data=data)[1]
dataset_X <- data.frame(model.matrix(frmla, data))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(lod)
for(i in 1:length(var_LOD)){
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>lod[i],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>lod[i],
subData[[var_LOD[i]]], subd[i])
}
# Create data for analysis
## Obs (Data), complete case (ccData), sub (subData), and sub sqrt2 (sub2Data) datasets
ccData <- Data[complete.cases(Data),]
######################################################################
# Enter convergence criterion, LOD, etc.                             #
######################################################################
n <- dim(Data)[1]
nObservations <- n
#######################################################################
# Perform Complete-Case, Substitution Analysis                        #
#######################################################################
ccModel <- glm( frmla,
family = gaussian(), data = ccData )
######################################################################
# Perform all Substitution Analyses                                  #
######################################################################
# Using LOD for sub
ccSub_LOD <- glm( frmla,
family = gaussian(), data = subData )
# Using LOD/sqrt(2) for sub
ccSub_LODsqrt2 <- glm( frmla,
family = gaussian(), data = sub2Data )
######################################################################
# Obtain parameter estimates to be used as initial estimates in ARMS #
######################################################################
# Extract Beta and residual variance
BetaEstimatesCC <- as.numeric( summary( ccModel )$coefficients[,1])
names(BetaEstimatesCC) <- rownames(summary( ccModel )$coefficients)
BetaEstimatesSubsqrt2 <- as.numeric( summary( ccSub_LODsqrt2 )$coefficients[,1])
names(BetaEstimatesSubsqrt2) <- rownames(summary( ccSub_LODsqrt2 )$coefficients)
# Extract mean vector estimate and covariance matrix estimate of covariates
cat_var <- names(ccModel$contrasts)
length_unique <- function(x){length(unique(x))}
unique_values <- apply(dataset_X, MARGIN=2,FUN=length_unique)
binary_vars <- names(unique_values[unique_values<3])
remove_vars <- c(var_LOD, cat_var, binary_vars)
var_noLOD <- names(dataset_X[,!(names(dataset_X)%in%remove_vars),
drop=FALSE])
var_keep <- names(ccData)[names(ccData) %in% c(var_noLOD, var_LOD)]
xMeanCC <- apply( ccData[,var_keep], 2, mean ) #-1 to eliminate outcome Y
xCovCC <- cov( ccData[,var_keep] )
#######################################################################
# Perform ARMS MLE Sampling using C++ compiled code                                          #
#######################################################################
# Create matrix to hold limits of detection
LOD_mat <- cbind(rep(-100, dim(Data[,-1])[2]), rep(NA, dim(Data[,-1])[2]))
LOD_mat[which(names(Data[,-1])%in%var_LOD),2] <- lod
dataset_Y <- model.frame(frmla,data=data)[1]
dataset_X <- data.frame(model.matrix(frmla, data))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(lod)
lod
var_LOD
var_LOD <- "X3"
lod <- 0
######################################################################
# Create required datasets                                           #
######################################################################
dataset_Y <- model.frame(frmla,data=data)[1]
dataset_X <- data.frame(model.matrix(frmla, data))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(lod)
for(i in 1:length(var_LOD)){
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>lod[i],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>lod[i],
subData[[var_LOD[i]]], subd[i])
}
# Create data for analysis
## Obs (Data), complete case (ccData), sub (subData), and sub sqrt2 (sub2Data) datasets
ccData <- Data[complete.cases(Data),]
######################################################################
# Enter convergence criterion, LOD, etc.                             #
######################################################################
n <- dim(Data)[1]
nObservations <- n
#######################################################################
# Perform Complete-Case, Substitution Analysis                        #
#######################################################################
ccModel <- glm( frmla,
family = gaussian(), data = ccData )
######################################################################
# Perform all Substitution Analyses                                  #
######################################################################
# Using LOD for sub
ccSub_LOD <- glm( frmla,
family = gaussian(), data = subData )
# Using LOD/sqrt(2) for sub
ccSub_LODsqrt2 <- glm( frmla,
family = gaussian(), data = sub2Data )
######################################################################
# Obtain parameter estimates to be used as initial estimates in ARMS #
######################################################################
# Extract Beta and residual variance
BetaEstimatesCC <- as.numeric( summary( ccModel )$coefficients[,1])
names(BetaEstimatesCC) <- rownames(summary( ccModel )$coefficients)
BetaEstimatesSubsqrt2 <- as.numeric( summary( ccSub_LODsqrt2 )$coefficients[,1])
names(BetaEstimatesSubsqrt2) <- rownames(summary( ccSub_LODsqrt2 )$coefficients)
# Extract mean vector estimate and covariance matrix estimate of covariates
cat_var <- names(ccModel$contrasts)
length_unique <- function(x){length(unique(x))}
unique_values <- apply(dataset_X, MARGIN=2,FUN=length_unique)
binary_vars <- names(unique_values[unique_values<3])
remove_vars <- c(var_LOD, cat_var, binary_vars)
var_noLOD <- names(dataset_X[,!(names(dataset_X)%in%remove_vars),
drop=FALSE])
var_keep <- names(ccData)[names(ccData) %in% c(var_noLOD, var_LOD)]
xMeanCC <- apply( ccData[,var_keep], 2, mean ) #-1 to eliminate outcome Y
xCovCC <- cov( ccData[,var_keep] )
#######################################################################
# Perform ARMS MLE Sampling using C++ compiled code                                          #
#######################################################################
# Create matrix to hold limits of detection
LOD_mat <- cbind(rep(-100, dim(Data[,-1])[2]), rep(NA, dim(Data[,-1])[2]))
LOD_mat[which(names(Data[,-1])%in%var_LOD),2] <- lod
debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
frmla <- Y ~ X1 + X3
dataset_Y <- model.frame(frmla,data=data)[1]
dataset_X <- data.frame(model.matrix(frmla, data))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(lod)
for(i in 1:length(var_LOD)){
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>lod[i],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>lod[i],
subData[[var_LOD[i]]], subd[i])
}
# Create data for analysis
## Obs (Data), complete case (ccData), sub (subData), and sub sqrt2 (sub2Data) datasets
ccData <- Data[complete.cases(Data),]
######################################################################
# Enter convergence criterion, LOD, etc.                             #
######################################################################
n <- dim(Data)[1]
nObservations <- n
#######################################################################
# Perform Complete-Case, Substitution Analysis                        #
#######################################################################
ccModel <- glm( frmla,
family = gaussian(), data = ccData )
######################################################################
# Perform all Substitution Analyses                                  #
######################################################################
# Using LOD for sub
ccSub_LOD <- glm( frmla,
family = gaussian(), data = subData )
# Using LOD/sqrt(2) for sub
ccSub_LODsqrt2 <- glm( frmla,
family = gaussian(), data = sub2Data )
######################################################################
# Obtain parameter estimates to be used as initial estimates in ARMS #
######################################################################
# Extract Beta and residual variance
BetaEstimatesCC <- as.numeric( summary( ccModel )$coefficients[,1])
names(BetaEstimatesCC) <- rownames(summary( ccModel )$coefficients)
BetaEstimatesSubsqrt2 <- as.numeric( summary( ccSub_LODsqrt2 )$coefficients[,1])
names(BetaEstimatesSubsqrt2) <- rownames(summary( ccSub_LODsqrt2 )$coefficients)
# Extract mean vector estimate and covariance matrix estimate of covariates
cat_var <- names(ccModel$contrasts)
length_unique <- function(x){length(unique(x))}
unique_values <- apply(dataset_X, MARGIN=2,FUN=length_unique)
binary_vars <- names(unique_values[unique_values<3])
remove_vars <- c(var_LOD, cat_var, binary_vars)
var_noLOD <- names(dataset_X[,!(names(dataset_X)%in%remove_vars),
drop=FALSE])
var_keep <- names(ccData)[names(ccData) %in% c(var_noLOD, var_LOD)]
xMeanCC <- apply( ccData[,var_keep], 2, mean ) #-1 to eliminate outcome Y
xCovCC <- cov( ccData[,var_keep] )
#######################################################################
# Perform ARMS MLE Sampling using C++ compiled code                                          #
#######################################################################
# Create matrix to hold limits of detection
LOD_mat <- cbind(rep(-100, dim(Data[,-1])[2]), rep(NA, dim(Data[,-1])[2]))
LOD_mat[which(names(Data[,-1])%in%var_LOD),2] <- lod
debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
frmla <- Y ~ X3 + X1
dataset_Y <- model.frame(frmla,data=data)[1]
dataset_X <- data.frame(model.matrix(frmla, data))[,-1]
subData <- data.frame(cbind(dataset_Y,Intercept=1,dataset_X))
Data <- subData
sub2Data <- subData
sqrt2LOd <- function(x){
ifelse(x>0, x/sqrt(2), x*sqrt(2))
}
subd <- sqrt2LOd(lod)
for(i in 1:length(var_LOD)){
Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>lod[i],
subData[[var_LOD[i]]], NA)
sub2Data[[var_LOD[i]]] <- ifelse(subData[[var_LOD[i]]]>lod[i],
subData[[var_LOD[i]]], subd[i])
}
# Create data for analysis
## Obs (Data), complete case (ccData), sub (subData), and sub sqrt2 (sub2Data) datasets
ccData <- Data[complete.cases(Data),]
######################################################################
# Enter convergence criterion, LOD, etc.                             #
######################################################################
n <- dim(Data)[1]
nObservations <- n
#######################################################################
# Perform Complete-Case, Substitution Analysis                        #
#######################################################################
ccModel <- glm( frmla,
family = gaussian(), data = ccData )
######################################################################
# Perform all Substitution Analyses                                  #
######################################################################
# Using LOD for sub
ccSub_LOD <- glm( frmla,
family = gaussian(), data = subData )
# Using LOD/sqrt(2) for sub
ccSub_LODsqrt2 <- glm( frmla,
family = gaussian(), data = sub2Data )
######################################################################
# Obtain parameter estimates to be used as initial estimates in ARMS #
######################################################################
# Extract Beta and residual variance
BetaEstimatesCC <- as.numeric( summary( ccModel )$coefficients[,1])
names(BetaEstimatesCC) <- rownames(summary( ccModel )$coefficients)
BetaEstimatesSubsqrt2 <- as.numeric( summary( ccSub_LODsqrt2 )$coefficients[,1])
names(BetaEstimatesSubsqrt2) <- rownames(summary( ccSub_LODsqrt2 )$coefficients)
# Extract mean vector estimate and covariance matrix estimate of covariates
cat_var <- names(ccModel$contrasts)
length_unique <- function(x){length(unique(x))}
unique_values <- apply(dataset_X, MARGIN=2,FUN=length_unique)
binary_vars <- names(unique_values[unique_values<3])
remove_vars <- c(var_LOD, cat_var, binary_vars)
var_noLOD <- names(dataset_X[,!(names(dataset_X)%in%remove_vars),
drop=FALSE])
var_keep <- names(ccData)[names(ccData) %in% c(var_noLOD, var_LOD)]
xMeanCC <- apply( ccData[,var_keep], 2, mean ) #-1 to eliminate outcome Y
xCovCC <- cov( ccData[,var_keep] )
#######################################################################
# Perform ARMS MLE Sampling using C++ compiled code                                          #
#######################################################################
# Create matrix to hold limits of detection
LOD_mat <- cbind(rep(-100, dim(Data[,-1])[2]), rep(NA, dim(Data[,-1])[2]))
LOD_mat[which(names(Data[,-1])%in%var_LOD),2] <- lod
debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
sourceCpp("ARMS_slice_LOD.cpp")
sourceCpp("ARMS_slice_LOD.cpp")
sourceCpp("ARMS_slice_LOD.cpp")
debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
debug2(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
sourceCpp("ARMS_slice_LOD.cpp")
debug2(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
xCovCC
debug2(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
debug(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
debug2(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
sourceCpp("ARMS_slice_LOD.cpp")
debug2(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
norm_multi_debug(-12.1217, x_preds = c(1,0,0.3197), )
debug2(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
debug2(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
sourceCpp("ARMS_slice_LOD.cpp")
debug2(y_data=Data[,1], x_data=as.matrix(Data[,-1]),
mean_x_preds=xMeanCC,
beta=BetaEstimatesCC,
sigma_2_y = sigma(ccModel)^2,
sigma_x_preds = xCovCC,
no_of_samples=nSamples,
threshold = convergenceCriterion,
max_iterations = 5,
LOD_u_l = LOD_mat,
sampler = 0)
